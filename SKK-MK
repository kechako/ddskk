;;; -*-Emacs-Lisp-*-

;; SKK-MK: installer for SKK.
;; Copyright (C) 1999, 2000 Mikio Nakajima <minakaji@osaka.email.ne.jp>

;; Author: Mikio Nakajima <minakaji@osaka.email.ne.jp>
;; Maintainer: Mikio Nakajima <minakaji@osaka.email.ne.jp>
;; Version: $Id: SKK-MK,v 1.31.2.1.2.35 2000/08/27 02:40:20 czkmt Exp $
;; Last Modified: $Date: 2000/08/27 02:40:20 $

;; Commentary
;;
;; Those values of variables below are default configurations.
;; If you would like to change some of those, you should edit SKK-CFG.
;;
;;              DO NOT EDIT THIS FILE DIRECTLY!
;;
;; Please note that all variables specified in the command line
;; overwrite ones defined in SKK-MK and SKK-CFG.
;;
;; Variable sections are all three parts.  GENERIC VARIABLE section,
;; NON-PACKAGE INSTALL RELATED VARIABLE section, and PACKAGE INSTALL
;; RELATED VARIABLE section.
;;
;; You can confirm target directories without an actual installation
;; by M-x SKK-MK-what-where or M-x SKK-MK-what-where-package after
;; load this program.

;;; Code:
;; tinyinstall.el is independent of APEL.
(require 'tinyinstall (expand-file-name "./tinyinstall"))

;;;; User variables to control SKK-MK.
(defvar SKK-MK-debugging nil "*Non-nil means making verbose output.")

;;;; Load configuration file.
;; load user custom file if exists.
(load (expand-file-name "./SKK-CFG") t nil t)

;;;; load-path related.
;; `install-prefix' is defined in tinyinstall.el.
;; Maybe it is `/usr/local', if you use UNIX.
(defvar EMU_PREFIX
  (or (getenv "EMU_PREFIX")
      (if (or (featurep 'xemacs)
	      (and (fboundp 'set-buffer-multibyte)
		   (subrp (symbol-function 'set-buffer-multibyte))))
	  "emu"
	"")))
(defvar PREFIX (or (getenv "PREFIX") install-prefix))
(defvar LISPDIR
  (let ((dir (expand-file-name
	      (or (getenv "LISPDIR")
		  (cond ((memq system-type '(ms-dos windows-nt))
			 (expand-file-name "site-lisp" PREFIX))
			(t
			 (install-detect-elisp-directory PREFIX)))))))
    (if (file-exists-p dir)
	(progn
	  ;; default-load-path takes effect for detecting directory.
	  (setq default-load-path (tinyinstall-add-load-path dir default-load-path))
	  dir))))
(defvar VERSION_SPECIFIC_LISPDIR
  (let ((dir (expand-file-name
	      (or (getenv "VERSION_SPECIFIC_LISPDIR")
		  (cond ((eq system-type 'windows-nt)
			 (expand-file-name "site-lisp" PREFIX))
			((eq system-type 'ms-dos)
			 (expand-file-name "site-lis" PREFIX))
			(t
			 (install-detect-elisp-directory PREFIX nil 'version-specific)))))))
    (if (file-exists-p dir) dir)))
(defvar APEL_SPECIFIC_LISPDIR (let ((dir (getenv "APEL_SPECIFIC_LISPDIR")))
				(and dir (file-exists-p dir) (expand-file-name dir))))

;; in case of defining these variables in SKK-CFG.
(and APEL_SPECIFIC_LISPDIR
     (setq APEL_SPECIFIC_LISPDIR (expand-file-name APEL_SPECIFIC_LISPDIR)))
(and LISPDIR (setq LISPDIR (expand-file-name LISPDIR)))
(and VERSION_SPECIFIC_LISPDIR
     (setq VERSION_SPECIFIC_LISPDIR (expand-file-name VERSION_SPECIFIC_LISPDIR)))

;; searching APEL installed directory...
(if (and LISPDIR (file-exists-p LISPDIR))
    (setq load-path (tinyinstall-add-load-path LISPDIR load-path)))

(let* ((emutmp)
       (apeldir
	(cond ((and APEL_SPECIFIC_LISPDIR (file-exists-p APEL_SPECIFIC_LISPDIR)
		    APEL_SPECIFIC_LISPDIR))
	      ((file-exists-p (expand-file-name "apel" LISPDIR))
	       (expand-file-name "apel" LISPDIR))
	      ;; Unix
	      ((file-exists-p (expand-file-name "../../site-lisp/apel" data-directory))
	       (expand-file-name "../../site-lisp/apel" data-directory))
	      ;; Mule for Windows.
	      ((and
		;; Following two lines identifies Mule for Windows, but are there
		;; any other Emacsen that have the same directory structure?
		;;(featurep 'mule) (eq system-type 'windows-nt)
		;;(= emacs-major-version 19)
		(file-exists-p (expand-file-name "../site-lisp/apel" exec-directory)))
	       (expand-file-name "../site-lisp/apel" exec-directory))))
       (emudir
	(cond ((and
		VERSION_SPECIFIC_LISPDIR
		(setq emutmp (expand-file-name EMU_PREFIX VERSION_SPECIFIC_LISPDIR))
		(cond ((and (file-exists-p emutmp)
			    (not (string= emutmp VERSION_SPECIFIC_LISPDIR))
			    (file-exists-p (expand-file-name "emu.el" emutmp))))
		      ((and
			(string= EMU_PREFIX "")
			;; try again with not standard emu directory.
			(setq emutmp (expand-file-name "emu" VERSION_SPECIFIC_LISPDIR))
			(not (string= emutmp VERSION_SPECIFIC_LISPDIR))
			(file-exists-p emutmp)
			(file-exists-p (expand-file-name "emu.el" emutmp))))))
	       emutmp)
	      ((and
		apeldir
		(setq emutmp (expand-file-name (concat "../" EMU_PREFIX) apeldir))
		(cond ((and (file-exists-p emutmp)
			    (not (string= emutmp VERSION_SPECIFIC_LISPDIR))
			    (file-exists-p (expand-file-name "emu.el" emutmp))))
		      ((and
			(string= EMU_PREFIX "")
			;; try again with not standard emu directory.
			(setq emutmp (expand-file-name "../emu" apeldir))
			(not (string= emutmp VERSION_SPECIFIC_LISPDIR))
			(file-exists-p emutmp)
			(file-exists-p (expand-file-name "emu.el" emutmp))))))
	       emutmp))))
  (and emudir
       (setq load-path (tinyinstall-add-load-path emudir load-path)))
  (and apeldir
       (setq load-path (tinyinstall-add-load-path apeldir load-path))))

(setq load-path (cons (expand-file-name ".") load-path))

(and VERSION_SPECIFIC_LISPDIR
     (file-exists-p VERSION_SPECIFIC_LISPDIR)
     (setq load-path (tinyinstall-add-load-path
		      (expand-file-name VERSION_SPECIFIC_LISPDIR) load-path)))

(if SKK-MK-debugging
    (progn
      (princ (format "APEL_SPECIFIC_LISPDIR=%s\n" APEL_SPECIFIC_LISPDIR))
      (princ (format "load-path=%s\n" load-path))))

;; After seaching APEL installed dirctory, require full set install.el.
(require 'poe)
(require 'install)

;; constants.
(defconst SKK-MK-running-xemacs (string-match "XEmacs" emacs-version))

(defconst SKK-MK-texinfo-coding-system
  (cond ((or SKK-MK-running-xemacs
	     (and (boundp 'mule-version)
		  (or (string< "4.0" mule-version) (string< "3.0" mule-version))))
	 'junet)
	((boundp 'MULE)
	 *junet*)
	(t
	 nil)))

;; GENERIC VARIABLE.
(defvar DOCDIR (or (getenv "DOCDIR") "./doc"))
(defvar ETCDIR (or (getenv "ETCDIR") "./etc"))
(defvar DICDIR (or (getenv "DICDIR") "./dic"))
(defvar SKK_INFOS
  (cond ((= 18 emacs-major-version)
	 nil)
	(t
	 (or (getenv "SKK_INFOS")
	     '("skk.info" "skk.info-1" "skk.info-2" "skk.info-3" "skk.info-4"
	       "skk.info-5" "skk.info-6")))))
(defvar SKK_MODULES
  ;; こんなもんコマンドラインで指定する人いないよね？
  (or (getenv "SKK_MODULES")
      (let ((list '(queue-m skk-macs skk-vars
			    skk skk-auto skk-autoloads skk-comp
			    skk-develop skk-gadget
			    skk-isearch skk-kakasi skk-kcode
			    skk-leim skk-look skk-num skk-obsolete
			    skk-cursor skk-server skk-tut
			    ;; EXPERIMENTAL
			    skk-abbrev skk-dcomp
			    skk-jisx0201 skk-rdbms skk-study
			    skk-tutcdef skk-tutcode skk-correct
			    skk-exsearch skk-exserv
			    skk-cursor2 ccc skk-cursor3 
			    ;; VIP 3.7
			    ;; vip
			    )))
	;; バイトコンパイル時に X window が initialize されていないというエラー
	;; になる (;_;)。
	;; yatex みたいに Window を開いてバイトコンパイルするようにもできるけど、
	;; no-window の make コマンドを別に作らなきゃならないし、面倒だな...。
        ;;(if (if SKK-MK-running-xemacs
        ;;        (eq (device-class (selected-device)) 'color)
        ;;      (x-display-color-p))
        ;;    (setq list (nconc list (list 'skk-cursor))))
	(and SKK-MK-running-xemacs
	     (member "skk-leim" preloaded-file-list)
	     (setq list (nconc list (list 'skk-xm20_4))))
	(or (fboundp 'register-input-method)
	    (setq list (delq 'skk-leim list)))
	(when (= 18 emacs-major-version)
	  (mapcar (function
		   (lambda (elt)
		     (setq list (delq elt list))))
		  '(skk-cursor skk-isearch skk-jisx0201 skk-study)))
	(condition-case nil
	    ;; you might have to add lookup installed directory to `load-path'.
	    (and (let ((lookup-byte-compile t)) (require 'lookup))
                 (setq list (nconc list (list 'skk-lookup))))
	  (error))
	(condition-case nil
	    (and (require 'viper) (setq list (nconc list (list 'skk-viper))))
	  (error))
	(and (or (featurep 'gdbm) (featurep 'dbm) (featurep 'berkdb)
		 (featurep 'berkeley-db))
	     (setq list (nconc list (list 'skk-dbm))))
	list)))
(defvar SKK_PREFIX (or (getenv "SKK_PREFIX") "skk"))
(defvar SKK_TEXIS (or (getenv "SKK_TEXIS") '("skk.texi")))
(defvar SKK_TUTORIALS (or (getenv "SKK_TUTORIALS") '("SKK.tut" "SKK.tut.E")))
(defvar SKK_DICTIONARIES
  (or (getenv "SKK_DICTIONARIES") '("SKK-JISYO.L" "SKK-JISYO.M" "SKK-JISYO.S")))

;; NON-PACKAGE INSTALL RELATED VARIABLE.
(defvar SKK_DATADIR
  (or (getenv "SKK_DATADIR")
      (expand-file-name SKK_PREFIX (expand-file-name "share" PREFIX))))
(defvar SKK_INFODIR
  (or (getenv "SKK_INFODIR")(expand-file-name "info" PREFIX)))
(defvar SKK_LISPDIR
  (or (getenv "SKK_LISPDIR") (expand-file-name SKK_PREFIX LISPDIR)))

;; PACKAGE INSTALL RELATED VARIABLE.
(defvar PACKAGEDIR
  (or (getenv "PACKAGEDIR")
      (if (boundp 'early-packages)
	  (let ((dirs
		 (append (if early-package-load-path early-packages)
			 (if late-package-load-path late-packages)
			 (if last-package-load-path last-packages)))
		dir)
	    (while (not (file-exists-p (setq dir (car dirs))))
	      (setq dirs (cdr dirs)))
	    dir))))

(defvar PACKAGE_INFODIR
  (or (getenv "PACKAGE_INFODIR") (expand-file-name "info" PACKAGEDIR)))

(defvar SKK_PACKAGE_DATADIR
  (or (getenv "SKK_PACKAGE_DATADIR")
      (expand-file-name SKK_PREFIX (expand-file-name "etc" PACKAGEDIR))))

(defvar SKK_PACKAGE_LISPDIR
  (or (getenv "SKK_PACKAGE_LISPDIR")
      (expand-file-name SKK_PREFIX (expand-file-name "lisp" PACKAGEDIR))))

(if SKK-MK-debugging (princ (format "SKK_MODULES=%s\n" SKK_MODULES)))

(defconst SKK_PACKAGE_NOT_USE '(skk-autoloads))
(defconst SKK_DAREDEVIL_NOT_USE '(skk-vip skk-foreword stack-m))

;; This code is for skk-jisx0201.el.
(cond ((fboundp 'make-translation-table) ;; Emacs 20.3 or later
       (setq standard-translation-table-for-decode
	     (make-translation-table nil)))
      ((fboundp 'make-unification-table) ;; Emacs 20.2
       (setq standard-character-unification-table-for-decode
	     (make-unification-table nil))))

;; Work around for Nemacs
(when (= 18 emacs-major-version)
  (require 'skk-e18 "experimental/skk-e18")
  (condition-case nil
      (delete-file "experimental/skk-isearch.el")
    (error))
  (copy-file "experimental/skk-is-n.el" "experimental/skk-isearch.el" nil t))

;;; [FUNCTIONS]
(defun SKK-MK-make-setup-file (spec)
  ;; SPEC は交代リスト。
  (with-temp-buffer
    (save-excursion
      (insert-file-contents "skk-setup.el.in")
      (goto-char (point-min))
      (when (looking-at ";;; -\\*- emacs-lisp -\\*-")
	(delete-region (point) (progn (forward-line 1) (point))))
      (when (search-forward ";;; skk-setup.el --- Initial setup for SKK")
	(forward-char 1)
	(insert ";; This file was generated automatically by SKK-MK at "
		(current-time-string)
		"\n"))
      (while spec
	(while (re-search-forward (concat "^;;[^@]+\\(" (car spec) "\\)")
				  nil t nil)
	  (delete-region (match-beginning 1) (match-end 1))
	  (insert (eval (nth 1 spec)))
	  (beginning-of-line)
	  (while (looking-at ";")
	    (delete-char 1)))
	(setq spec (nthcdr 2 spec)))
      (write-region (point-min) (point-max) "skk-setup.el"))))
	
(defun SKK-MK-compile ()
  (cond ((= 18 emacs-major-version)
	 (let ((SKK_MODULES (cons 'experimental/skk-isearch SKK_MODULES)))
	   (SKK-MK-generate-autoloads-el))
	 (compile-elisp-modules '(skk-e18 skk-isearch) "./experimental"))
	(t
	 (SKK-MK-generate-autoloads-el)))
  (compile-elisp-modules SKK_MODULES (expand-file-name ".")))

(defun SKK-MK-compile-info ()
  (and SKK_INFOS
       (if (or (not (file-exists-p (expand-file-name (car SKK_INFOS) DOCDIR)))
	       (file-newer-than-file-p (expand-file-name (car SKK_TEXIS) DOCDIR)
				       (expand-file-name (car SKK_INFOS) DOCDIR)))
	   (SKK-MK-texinfo-format SKK_TEXIS))))

(defun SKK-MK-install ()
  (let ((dics SKK_DICTIONARIES)
	delete-target exists spec)
    ;; make target directories.
    (setq DOCDIR (expand-file-name DOCDIR)
	  ETCDIR (expand-file-name ETCDIR)
	  DICDIR (expand-file-name DICDIR))
    (or (file-exists-p SKK_LISPDIR)
	(make-directory SKK_LISPDIR t))
    (or (file-exists-p SKK_DATADIR)
	(make-directory SKK_DATADIR t))
    (or (file-exists-p SKK_INFODIR)
	(make-directory SKK_INFODIR t))
    ;; delete already installed unnecessary files.
    (while SKK_DAREDEVIL_NOT_USE
      (setq SKK_MODULES (delq (car SKK_DAREDEVIL_NOT_USE) SKK_MODULES)
	    delete-target (expand-file-name
			   (concat (prin1-to-string (car SKK_DAREDEVIL_NOT_USE))
				   ".el")
			   SKK_LISPDIR)
	    SKK_DAREDEVIL_NOT_USE (cdr SKK_DAREDEVIL_NOT_USE))
      (and (file-exists-p delete-target) (delete-file delete-target))
      (setq delete-target (concat delete-target "c"))
      (and (file-exists-p delete-target) (delete-file delete-target)))
    ;; install Emacs Lisp programs.
    (SKK-MK-compile)
    (when (= 18 emacs-major-version)
      (install-elisp-modules '(skk-e18 skk-isearch) "./experimental" SKK_LISPDIR))
    (install-elisp-modules SKK_MODULES "." SKK_LISPDIR)
    ;; install infos.
    (SKK-MK-compile-info)
    (install-files SKK_INFOS DOCDIR SKK_INFODIR nil t nil)
    ;; install tutorials.
    (install-files SKK_TUTORIALS ETCDIR SKK_DATADIR nil t nil)
    ;; make skk-setup.el.
    (while dics
      (when (file-exists-p (expand-file-name (car dics) DICDIR))
	(setq exists (cons (car dics) exists)))
      (setq dics (cdr dics)))
    (setq SKK_DICTIONARIES exists)
    ;; move existing largest dictionay to car of `SKK_DICTIONARIES'.
    (and (member "SKK-JISYO.M" SKK_DICTIONARIES)
	 (setq SKK_DICTIONARIES
	       (cons "SKK-JISYO.M" (delete "SKK-JISYO.M" SKK_DICTIONARIES))))
    (and (member "SKK-JISYO.L" SKK_DICTIONARIES)
	 (setq SKK_DICTIONARIES
	       (cons "SKK-JISYO.L" (delete "SKK-JISYO.L" SKK_DICTIONARIES))))
    (if SKK_DICTIONARIES
	(progn
	  (setq spec '("@DIC@"
		       (expand-file-name (car SKK_DICTIONARIES) SKK_DATADIR)))
	  (if SKK_TUTORIALS
	      (setq spec (append spec '("@TUT@"
					(expand-file-name
					 (car SKK_TUTORIALS) SKK_DATADIR)))))
	  (SKK-MK-make-setup-file spec)
	  ;; install dictionaries if the files exist in ./dic directory.
	  (install-files SKK_DICTIONARIES DICDIR SKK_DATADIR nil t nil))
      ;; when dictionaries do not exist in ./dic subdirectory, check
      ;; already installed dictionary and detect largest one to setup
      ;; skk-setup.el.in.
      (setq dics '("SKK-JISYO.L" "SKK-JISYO.M" "SKK-JISYO.S"))
      (while (and dics
		  (not
		   (file-exists-p (expand-file-name (car dics) SKK_DATADIR))))
	(setq dics (cdr dics)))
      (if dics
	  (progn
	    (setq spec '("@DIC@" (expand-file-name (car dics) SKK_DATADIR)))
	    (if SKK_TUTORIALS
		(setq spec (append spec '("@TUT@"
					  (expand-file-name
					   (car SKK_TUTORIALS) SKK_DATADIR)))))
	    (SKK-MK-make-setup-file spec))
	;; merely copy without setup dictionary information.
	(copy-file "skk-setup.el.in" "skk-setup.el" 'ok-if-already-exists)))
    ;;
    (when (fboundp 'register-input-method)
      (copy-file "skk-setup.el" "leim-list.el" 'ok-if-already-exists)
      (install-elisp-modules (list 'leim-list) "." SKK_LISPDIR))
    ;; install skk-setup.el
    (install-elisp-modules (list 'skk-setup) "." SKK_LISPDIR)))

(defun SKK-MK-install-package ()
  (let ((not-use (append SKK_PACKAGE_NOT_USE SKK_DAREDEVIL_NOT_USE))
	(dics SKK_DICTIONARIES)
	delete-target exist)
    (or (featurep 'xemacs) (error "This directive is only for XEmacs."))
    ;; make target directories.
    (or (file-exists-p SKK_PACKAGE_LISPDIR)
	(make-directory SKK_PACKAGE_LISPDIR t))
    (or (file-exists-p SKK_PACKAGE_DATADIR)
	(make-directory SKK_PACKAGE_DATADIR t))
    (or (file-exists-p PACKAGE_INFODIR)
	(make-directory PACKAGE_INFODIR t))
    ;; delete already installed unnecessary files.
    (while not-use
      (setq SKK_MODULES (delq (car not-use) SKK_MODULES)
	    delete-target (expand-file-name
			   (concat (prin1-to-string (car not-use)) ".el")
			   SKK_PACKAGE_LISPDIR)
	    not-use (cdr not-use))
      (and (file-exists-p delete-target) (delete-file delete-target))
      (setq delete-target (concat delete-target "c"))
      (and (file-exists-p delete-target) (delete-file delete-target)))
    ;; install Emacs Lisp programs.
    (compile-elisp-modules SKK_MODULES ".")
    (install-elisp-modules SKK_MODULES "." SKK_PACKAGE_LISPDIR)
    (setq autoload-package-name "skk")
    (add-to-list 'command-line-args-left SKK_PACKAGE_LISPDIR)
    (batch-update-directory)
    (add-to-list 'command-line-args-left SKK_PACKAGE_LISPDIR)
    (Custom-make-dependencies)
    (byte-compile-file (expand-file-name "auto-autoloads.el" SKK_PACKAGE_LISPDIR))
    (byte-compile-file (expand-file-name "custom-load.el" SKK_PACKAGE_LISPDIR))
    ;; install infos.
    (SKK-MK-compile-info)
    (install-files SKK_INFOS DOCDIR PACKAGE_INFODIR nil t nil)
    ;; install tutorials.
    (install-files SKK_TUTORIALS ETCDIR SKK_PACKAGE_DATADIR nil t nil)
    ;; make skk-setup.el.
    (while dics
      (when (file-exists-p (expand-file-name (car dics) DICDIR))
	(setq exist (cons (car dics) exist)))
      (setq dics (cdr dics)))
    (setq SKK_DICTIONARIES exist))
  ;; move existing largest dictionay to car of `SKK_DICTIONARIES'.
  (and (member "SKK-JISYO.M" SKK_DICTIONARIES)
       (setq SKK_DICTIONARIES
	     (cons "SKK-JISYO.M" (delete "SKK-JISYO.M" SKK_DICTIONARIES))))
  (and (member "SKK-JISYO.L" SKK_DICTIONARIES)
       (setq SKK_DICTIONARIES
	     (cons "SKK-JISYO.L" (delete "SKK-JISYO.L" SKK_DICTIONARIES))))
  (if SKK_DICTIONARIES
      (progn
	(SKK-MK-make-setup-file
	 '("@DIC@" (expand-file-name (car SKK_DICTIONARIES) SKK_PACKAGE_DATADIR)))
	;; install dictionaries if the files exist in ./dic directory.
	(install-files SKK_DICTIONARIES DICDIR SKK_PACKAGE_DATADIR nil t nil))
    ;; when dictionaries do not exist in ./dic subdirectory, check
    ;; already installed dictionary and detect largest one to setup
    ;; skk-setup.el.in.
    (setq dics '("SKK-JISYO.L" "SKK-JISYO.M" "SKK-JISYO.S"))
    (while (and dics
		(not
		 (file-exists-p (expand-file-name (car dics) SKK_PACKAGE_DATADIR))))
      (setq dics (cdr dics)))
    (if dics
	(SKK-MK-make-setup-file
	 '("@DIC@" (expand-file-name (car dics) SKK_PACKAGE_DATADIR)))
      ;; merely copy without setup dictionary information.
      (copy-file "skk-setup.el.in" "skk-setup.el" 'ok-if-already-exists)))
  ;; install skk-setup.el
  (copy-file "skk-setup.el" "leim-list.el" 'ok-if-already-exists)
  (install-elisp-modules (list 'skk-setup 'leim-list) "." SKK_PACKAGE_LISPDIR))

(defun SKK-MK-texinfo-format (targets)
  (let (
	;; Emacs20.2's default is 'raw-text-unix.
	(coding-system-for-write SKK-MK-texinfo-coding-system)
	x obuf beg standard-output)
    (require 'ptexinfmt (expand-file-name "ptexinfmt.el" default-directory))
    (while targets
      (setq x (expand-file-name (car targets) DOCDIR))
      (find-file x)
      (setq obuf (current-buffer))
      (texinfo-format-buffer)
      (save-buffer)
      (kill-buffer (current-buffer))	; info
      (kill-buffer obuf)		; texi
      (setq targets (cdr targets)))))

(defun SKK-MK-what-where ()
  (interactive)
  (let ((string
	 (format "
SKK modules:
  %s
  -> %s

SKK infos:
  %s
  -> %s

SKK tutorials:
  %s
  -> %s
"
		 (mapconcat 'symbol-name SKK_MODULES ", ")
		 SKK_LISPDIR
		 (mapconcat 'identity SKK_INFOS ", ")
		 SKK_INFODIR
		 (mapconcat 'identity SKK_TUTORIALS ", ")
		 SKK_DATADIR)))
    (if (interactive-p)
	(progn (with-output-to-temp-buffer "*What where*" (princ string))
	       (message ""))
      (princ string))))

(defun SKK-MK-what-where-package ()
  (interactive)
  (or (featurep 'xemacs) (error "This directive is only for XEmacs."))
  (let ((string
	 (format "
SKK modules:
  %s
  -> %s

SKK infos:
  %s
  -> %s

SKK tutorials:
  %s
  -> %s
"
		 (mapconcat 'symbol-name SKK_MODULES ", ")
		 SKK_PACKAGE_LISPDIR
		 (mapconcat 'identity SKK_INFOS ", ")
		 PACKAGE_INFODIR
		 (mapconcat 'identity SKK_TUTORIALS ", ")
		 SKK_PACKAGE_DATADIR)))
    (if (interactive-p)
	(progn (with-output-to-temp-buffer "*What where*" (princ string))
	       (message ""))
      (princ string))))

(defun SKK-MK-generate-autoloads-el ()
  "Generate skk-autoload.el."
  (let ((modules SKK_MODULES)
        (buf (get-buffer-create " *SKK-MK-generate-autoloads-el*"))
        (sort-min)
        (funcs)
	standard-output)
    (save-excursion
      (set-buffer buf)
      (erase-buffer)
      (insert "\
;;; skk-autoloads.el --- autoload settings for SKK.

;; This file was generated automatically by SKK-MK at "
              (current-time-string)
              ".

;; This file is part of Daredevil SKK.

;; Daredevil SKK is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation; either versions 2, or (at your option)
;; any later version.

;; Daredevil SKK is distributed in the hope that it will be useful
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with Daredevil SKK, see the file COPYING.  If not, write to the Free
;; Software Foundation Inc., 59 Temple Place - Suite 330, Boston,
;; MA 02111-1307, USA.

;;; Code:\n\n")
      (cond
       ((and (condition-case nil
		 (and (require 'autoload)
		      (require 'poem))
	       (error))
	     (fboundp 'generate-file-autoloads))
	(mapcar
	 (function
	  (lambda (module)
	    (let ((file (expand-file-name (format "%s.el" module) default-directory)))
	      (and (file-exists-p file)
		     (generate-file-autoloads file)))))
	 modules)
	(goto-char (point-max))
	(insert "\n(provide 'skk-autoloads)\n;;; skk-autoloads.el ends here\n")
	(write-region-as-coding-system
	 (if (boundp 'MULE) *junet*unix 'iso-2022-7bit)
	 (point-min) (point-max) "skk-autoloads.el" nil 'quiet)
	(kill-buffer buf))
       (t
	(setq sort-min (point))
	(while modules
	  (setq funcs (SKK-MK-collect-autoload-functions (car modules)))
	  (while funcs
	    (insert "(autoload '" (caar funcs)
		    " \"" (file-name-nondirectory (symbol-name (car modules)))
		    "\" nil "
		    (symbol-name (if (cdar funcs) t))
		    " nil)\n")
	    (setq funcs (cdr funcs)))
	  (setq modules (cdr modules)))
	(sort-lines nil sort-min (point-max))
	(goto-char (point-max))
	(insert "\n(provide 'skk-autoloads)\n;;; skk-autoloads.el ends here\n")
	(write-region (point-min) (point-max) "skk-autoloads.el" nil 'quiet)
	(kill-buffer buf))))))

(defun SKK-MK-collect-autoload-functions (module)
  "Return a list of autoload functions defined in MODULE."
  (let ((el-file (concat (symbol-name module) ".el"))
        (funcs))
    (if (file-exists-p el-file)
        (progn
          (save-excursion
            (insert-file-contents el-file)
            (while (re-search-forward "^;;;###autoload" nil t)
              (beginning-of-line 2)
              (if (looking-at "(defun[ 	]+\\([^ 	(]+\\)")
                  (setq funcs
                        (cons (cons (match-string 1)
                                    (save-excursion
                                      (re-search-forward
                                       "^[ 	]*(interactive"
                                       (save-excursion
					 (re-search-forward "^(defun" nil t 2))
                                       t)))
                              funcs)))))
          (delete-region (point) (point-max))))
    funcs))

;;; SKK-MK ends here
